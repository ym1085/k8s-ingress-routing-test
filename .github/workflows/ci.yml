# GitHub Action Workflow(워크플로우)
name: Build and Push Docker Image

# Event(이벤트)
on:
  push:
    branches:
      - dev
      - stg
    tags:
      - "v*.*.*" # Git Tag 추가(Production)

# Jobs(잡)
jobs:
  # Step 1 : 변경된 파일 분석
  detect-changes:
    # Github Actions가 제공하는 가상머신에서 Job을 실행하며, Azure에 구동되는 듯
    # 1회성으로 실행되는 서버로, 회사 내부 서버나 내부망에서 접근 힘들기에 필요하면 self-hosted 서버 사용
    runs-on: ubuntu-latest
    outputs:
      # filter ID를 갖는 steps에서 변경된 부분을 저장
      # ex: ["order"] or ["order", "user"]
      services: ${{ steps.filter.outputs.changes }}
    steps:
      # uses: 이미 만들어진 Github Action을 가져다 쓰겠다는 선언
      # id: 이 step에 붙이는 이름표, 해당 step이 만든 결과를 다른 곳에서 참조하기 위한 식별자

      - uses: actions/checkout@v4 # Github Action 서버에 내 레포 코드 가져오기(Git Clone)
      - uses: dorny/paths-filter@v3 # 어떤 폴더/파일이 바뀌었는지 분석하는 Action 실행
        id: filter
        # dorny/paths-filter Action에 넘겨주는 설정값(파라미터)
        # filters는 어떤 파일이 바뀌면, 어떤 서비스가 바뀐걸로 볼지 규칙 정의
        with:
          filters: |
            order:
              - 'order-service/**'
              - 'common/**' # common 수정 시 order 빌드 포함
              - 'build.gradle'
            user:
              - 'user-service/**'
              - 'common/**' # common 수정 시 user 빌드 포함
              - 'build.gradle'

  # Step 2 : 변경된 서비스만 병렬 빌드 및 업데이트
  build-jar:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.services != '[]' }} # 변경된 서비스가 있을 때만 실행
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # JDK 설정 및 빌드 (해당 모듈만)
      - name: Set up JDK 17
        uses: actions/setup-java@v4 # Github에서 제공하는 Action, 러너 VM에 Java 설치/설정
        with:
          java-version: "17" # 빌드에 사용할 JDK 버전 지정
          distribution: "temurin" # JDK 배포판 선택
          cache: "gradle" # 의존성 캐시 활성화

      # 특정 모듈만 빌드
      - name: Build JAR
        run: ./gradlew :${{ matrix.service }}-service:build -x test

      # 생성된 JAR 파일을 아티팩트로 업로드
      - name: Upload JAR Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: ${{ matrix.service }}-service/build/libs/*.jar
          retention-days: 1 # 보안 및 저장 용량 관리를 위해 짧게 설정
  # Step 3 : 환경(Profile)별 Docker image 업로드
  push-image:
    needs: [build-jar, detect-changes]
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 이전 Job에서 빌드한 JAR 파일 다운로드
      - name: Download JAR Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: ${{ matrix.service }}-service/build/libs/

      #  Docker 빌드 및 푸시
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      - name: Build and Push Image
        run: |
          IMAGE_NAME="youngmin1085/${{ matrix.service }}-service"
          
          # Git Tag로 푸시된 경우 (Production 릴리즈)
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v} # v1.2.3 -> 1.2.3
            echo "Production Release: $VERSION"
            docker build -t $IMAGE_NAME:$VERSION \
                   -t $IMAGE_NAME:latest \
                   ./${{ matrix.service }}-service
            docker push $IMAGE_NAME:$VERSION
            docker push $IMAGE_NAME:latest
          else
            if [[ $GITHUB_REF == refs/heads/stg ]]; then
              ENV_TAG="stg"
            else
              ENV_TAG="dev"
            fi
            SHORT_SHA=${GITHUB_SHA::7}
            echo "Environment: $ENV_TAG"

            docker build -t $IMAGE_NAME:${ENV_TAG}-${SHORT_SHA} \
                         ./${{ matrix.service }}-service
            docker push $IMAGE_NAME:${ENV_TAG}-${SHORT_SHA}
            # docker push $IMAGE_NAME:$ENV_TAG
          fi
